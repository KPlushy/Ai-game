<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML Mobile Parkour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #301934; /* Darker purple for area outside game */
            font-family: Arial, sans-serif;
            color: white;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #E6E6FA; /* Light purple background for the container in fullscreen */
            padding: 10px;
            box-sizing: border-box;
            border-radius: 8px;
        }
        #fullscreenBtn {
            margin-bottom: 10px;
            padding: 8px 15px;
            background-color: #6A0DAD;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            width: 90%;
            max-width: 340px;
        }
        #fullscreenBtn:hover {
            background-color: #8A2BE2;
        }
        canvas {
            border: 2px solid #4A0072;
            display: block;
        }
        #controlsInfo {
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(74, 0, 114, 0.8);
            border-radius: 5px;
            text-align: center;
            width: 90%;
            max-width: 340px;
        }
        #controlsInfo p {
            margin: 5px 0;
        }
        #messageDisplay {
            min-height: 1.2em; /* Reserve space for messages */
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="fullscreenBtn">Go Fullscreen</button>
        <canvas id="gameCanvas"></canvas>
        <div id="controlsInfo">
            <p><strong>Controls:</strong></p>
            <p>Left/Right Arrows: Move | Up Arrow/Space: Jump</p>
            <p>X: Place Block | C: Dash</p>
            <p id="blockCount">Blocks: 3</p>
            <p id="levelDisplay">Level: 1</p>
            <p id="messageDisplay"></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blockCountDisplay = document.getElementById('blockCount');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const gameContainer = document.getElementById('gameContainer');

        let gameWidth = 360;
        let gameHeight = 500;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        const gravity = 0.5;
        const playerSpeed = 3;
        const jumpStrength = -10;
        const dashSpeed = 8;
        const dashDuration = 150;
        const maxBlocks = 3;
        const blockWidth = 40;
        const blockHeight = 20;

        const groundColor = '#6A0DAD';
        const playerColor = '#8A2BE2';
        const blockColor = '#9932CC';
        const spikeColor = '#4B0082';
        const startColor = '#7FFF00';
        const goalColor = '#FFD700';
        const gameBackgroundColor = '#E6E6FA';

        let player = {
            x: 50, y: gameHeight - 80,
            width: 30, height: 30,
            dx: 0, dy: 0,
            onGround: false,
            blocksAvailable: maxBlocks,
            isDashing: false, dashTimer: 0, dashDirection: 0
        };

        let placedBlocks = [];
        let currentLevel = 1;
        let isLevelTransitioning = false; // Prevents rapid level up

        let keys = { left: false, right: false, up: false };

        let ground, startZone, goalZone, spikes;

        function setupLevel(levelNumber) {
            isLevelTransitioning = false; // Reset flag at the start of new level setup
            player.x = 50;
            player.y = gameHeight - 80; // Initial Y, will be adjusted by startZone
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
            player.blocksAvailable = maxBlocks;
            placedBlocks = [];

            // Clear generic messages, keep difficulty messages if they were just set
            if (messageDisplay.textContent.startsWith("Advancing to")) {
                 messageDisplay.textContent = "";
            }


            // --- Dynamic Level Generation & Difficulty ---
            let newSpikes = [];
            let newGoal = { x: gameWidth - 70, y: gameHeight - 70, width: 60, height: 30 };
            let newGroundY = gameHeight - 40;

            // Ground: For now, ground is fixed. Could be varied later.
            ground = { x: 0, y: newGroundY, width: gameWidth, height: 40 };
            startZone = { x: 10, y: newGroundY - 30, width: 60, height: 30 };
            player.y = startZone.y - player.height -1; // Place player on start platform

            // Difficulty scaling for spikes
            const baseNumSpikes = 1;
            let numSpikesToGenerate = baseNumSpikes + Math.floor(levelNumber / 2.5); // Increases faster
            numSpikesToGenerate = Math.min(numSpikesToGenerate, 8); // Max 8 spikes

            for (let i = 0; i < numSpikesToGenerate; i++) {
                let spikeX, spikeY, spikeW;
                let attempts = 0;
                let validPosition = false;
                while (!validPosition && attempts < 20) {
                    spikeW = 30 + Math.random() * 15;
                    spikeX = 80 + Math.random() * (gameWidth - 160 - spikeW); // Avoid start/end zones typically

                    if (levelNumber > 3 && Math.random() > 0.4) { // Chance for "floating" spikes
                        spikeY = newGroundY - 20 - (Math.random() * 120); // Floating spike
                        spikeY = Math.max(80, spikeY); // Not too high initially
                    } else {
                        spikeY = newGroundY - 20; // Spike on the ground
                    }
                    let newSpike = { x: spikeX, y: spikeY, width: spikeW, height: 20 };

                    // Basic check: not too close to start, not overlapping other spikes too much
                    let tooCloseToStart = newSpike.x < startZone.x + startZone.width + 20;
                    let overlapsOtherSpike = newSpikes.some(s => Math.abs(s.x - newSpike.x) < s.width);

                    if (!tooCloseToStart && !overlapsOtherSpike) {
                        validPosition = true;
                        newSpikes.push(newSpike);
                    }
                    attempts++;
                }
                if (!validPosition && newSpikes.length <= i) { // Fallback if complex placement fails
                     newSpikes.push({ x: 100 + (i * 60 % (gameWidth - 150)), y: newGroundY - 20, width: 35, height: 20});
                }
            }
            spikes = newSpikes;

            // Vary Goal Position
            if (levelNumber === 1) {
                newGoal.x = gameWidth - 70;
                newGoal.y = newGroundY - 30;
            } else {
                newGoal.x = (gameWidth / 2) + (Math.random() * (gameWidth / 2 - newGoal.width - 20));
                if (levelNumber % 3 === 0 || levelNumber > 7) { // Higher goals more often
                    newGoal.y = 80 + Math.random() * (gameHeight / 2.5);
                } else {
                    newGoal.y = newGroundY - 30 - (Math.random() * 80);
                }
                newGoal.y = Math.max(60, newGoal.y); // Keep on screen
                newGoal.y = Math.min(newGoal.y, newGroundY - newGoal.height - 5);
            }
            goalZone = newGoal;

            // Set specific difficulty messages if this level is a milestone
            if (levelNumber > 10 && levelNumber % 10 === 1) {
                messageDisplay.textContent = `Level ${levelNumber}! Difficulty Ramping Up!`;
            } else if (levelNumber > 20 && (levelNumber % 5 === 1 || levelNumber % 5 === 0) ) {
                messageDisplay.textContent = `Level ${levelNumber}! Almost Impossible!`;
            } else if (messageDisplay.textContent.startsWith("Advancing to")) { // Clear generic advance message if no specific one applies
                messageDisplay.textContent = "";
            }


            updateUI();
        }


        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function resetPlayer() {
            // Use the current level's startZone for accurate reset
            const currentStart = startZone || { x: 10, y: (ground ? ground.y : gameHeight - 40) - 30, width: 60, height: 30 };
            player.x = currentStart.x + currentStart.width / 2 - player.width / 2;
            player.y = currentStart.y - player.height - 1;
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
            messageDisplay.textContent = "Ouch! Try again.";
            setTimeout(() => { if(messageDisplay.textContent === "Ouch! Try again.") messageDisplay.textContent = ""; }, 1500);
        }

        function update() {
            if (player.isDashing) {
                player.dashTimer -= 1000 / 60;
                if (player.dashTimer <= 0) {
                    player.isDashing = false; player.dx = 0;
                } else {
                    player.dx = player.dashDirection * dashSpeed; player.dy = 0;
                }
            } else {
                player.dx = 0;
                if (keys.left) player.dx = -playerSpeed;
                if (keys.right) player.dx = playerSpeed;
            }
            player.x += player.dx;

            if (!player.isDashing) {
                player.dy += gravity; player.y += player.dy;
            }
            player.onGround = false;

            if (ground && player.y + player.height > ground.y) {
                player.y = ground.y - player.height; player.dy = 0; player.onGround = true;
            }

            placedBlocks.forEach(block => {
                if (rectCollision(player, block)) {
                    if (player.dy > 0 && player.y + player.height - player.dy <= block.y) {
                        player.y = block.y - player.height; player.dy = 0; player.onGround = true;
                    } else if (player.dx > 0 && player.x + player.width - player.dx <= block.x) {
                        player.x = block.x - player.width; player.dx = 0;
                    } else if (player.dx < 0 && player.x - player.dx >= block.x + block.width) {
                        player.x = block.x + block.width; player.dx = 0;
                    }
                }
            });

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > gameWidth) player.x = gameWidth - player.width;

            if (spikes) {
                spikes.forEach(spike => {
                    if (rectCollision(player, spike)) resetPlayer();
                });
            }

            if (startZone && rectCollision(player, startZone)) {
                if (player.blocksAvailable < maxBlocks) {
                    player.blocksAvailable = maxBlocks;
                    messageDisplay.textContent = "Blocks Refilled!"; updateUI();
                    setTimeout(() => { if(messageDisplay.textContent === "Blocks Refilled!") messageDisplay.textContent = ""; }, 1500);
                }
            }

            if (goalZone && rectCollision(player, goalZone) && !isLevelTransitioning) {
                isLevelTransitioning = true;
                currentLevel++;

                let transitionMessage = `Advancing to Level ${currentLevel}...`;
                // Check upcoming level for difficulty message
                if (currentLevel > 10 && currentLevel % 10 === 1) {
                    transitionMessage = `Level ${currentLevel}! Difficulty Ramping Up!`;
                } else if (currentLevel > 20 && (currentLevel % 5 === 1 || currentLevel % 5 === 0)) {
                     transitionMessage = `Level ${currentLevel}! Almost Impossible!`;
                }
                messageDisplay.textContent = transitionMessage;

                setTimeout(() => {
                    setupLevel(currentLevel);
                }, 1000); // Quicker room shift
            }

            if (player.y > canvas.height + player.height) resetPlayer();
        }

        function draw() {
            ctx.fillStyle = gameBackgroundColor;
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            if (ground) {
                ctx.fillStyle = groundColor;
                ctx.fillRect(ground.x, ground.y, ground.width, ground.height);
            }
            if (startZone) {
                ctx.fillStyle = startColor;
                ctx.fillRect(startZone.x, startZone.y, startZone.width, startZone.height);
                ctx.fillStyle = 'black'; ctx.textAlign = 'center';
                ctx.fillText("START", startZone.x + startZone.width / 2, startZone.y + startZone.height / 2 + 5);
            }
            if (goalZone) {
                ctx.fillStyle = goalColor;
                ctx.fillRect(goalZone.x, goalZone.y, goalZone.width, goalZone.height);
                ctx.fillStyle = 'black'; ctx.textAlign = 'center';
                ctx.fillText("GOAL", goalZone.x + goalZone.width / 2, goalZone.y + goalZone.height / 2 + 5);
            }
            if (spikes) {
                ctx.fillStyle = spikeColor;
                spikes.forEach(spike => {
                    ctx.beginPath();
                    ctx.moveTo(spike.x, spike.y + spike.height);
                    ctx.lineTo(spike.x + spike.width / 2, spike.y);
                    ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
                    ctx.closePath(); ctx.fill();
                });
            }
            ctx.fillStyle = blockColor;
            placedBlocks.forEach(block => {
                ctx.fillRect(block.x, block.y, block.width, block.height);
            });
            ctx.fillStyle = player.isDashing ? '#FF69B4' : playerColor;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function updateUI() {
            blockCountDisplay.textContent = `Blocks: ${player.blocksAvailable}`;
            levelDisplay.textContent = `Level: ${currentLevel}`;
        }

        function placeBlock() {
            if (player.blocksAvailable > 0) {
                placedBlocks.push({
                    x: player.x + (player.width / 2) - (blockWidth / 2),
                    y: player.y + player.height, width: blockWidth, height: blockHeight
                });
                player.blocksAvailable--; updateUI();
            } else {
                messageDisplay.textContent = "Out of blocks!";
                setTimeout(() => { if(messageDisplay.textContent === "Out of blocks!") messageDisplay.textContent = ""; }, 1500);
            }
        }

        function performDash() {
            if (!player.isDashing) {
                player.isDashing = true; player.dashTimer = dashDuration;
                if (keys.left) player.dashDirection = -1;
                else if (keys.right) player.dashDirection = 1;
                else player.dashDirection = (player.x < gameWidth / 2 ? 1 : -1);
                if (player.dashDirection === 0) player.dashDirection = 1;
            }
        }

        function gameLoop() {
            update(); draw(); requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', function(e) {
            if (document.activeElement === fullscreenBtn && e.key === 'Enter') {
                if (!document.fullscreenElement) openFullscreen(gameContainer); else closeFullscreen();
                return;
            }
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === ' ') {
                e.preventDefault(); keys.up = true;
                if (player.onGround && !player.isDashing) { player.dy = jumpStrength; player.onGround = false; }
            }
            if (e.key === 'x' || e.key === 'X') placeBlock();
            if (e.key === 'c' || e.key === 'C') performDash();
        });
        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === ' ') keys.up = false;
        });

        function openFullscreen(elem) {
            if (elem.requestFullscreen) elem.requestFullscreen();
            else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
            else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
            else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
        }
        function closeFullscreen() {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
        }
        fullscreenBtn.addEventListener('click', function() {
            if (!document.fullscreenElement) openFullscreen(gameContainer); else closeFullscreen();
        });
        function updateFullscreenButtonText() {
            fullscreenBtn.textContent = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ? "Exit Fullscreen" : "Go Fullscreen";
        }
        document.addEventListener('fullscreenchange', updateFullscreenButtonText);
        document.addEventListener('mozfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('msfullscreenchange', updateFullscreenButtonText);

        setupLevel(currentLevel);
        updateFullscreenButtonText();
        gameLoop();
    </script>
</body>
</html>
