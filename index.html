<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML Mobile Parkour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #301934; /* Darker purple for area outside game */
            font-family: Arial, sans-serif;
            color: white;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #E6E6FA; /* Light purple background for the container in fullscreen */
            padding: 10px;
            box-sizing: border-box;
            border-radius: 8px; /* Optional: nice rounded corners for the container */
        }
        #fullscreenBtn { /* MOVED TO TOP */
            margin-bottom: 10px; /* Space below the button */
            padding: 8px 15px;
            background-color: #6A0DAD;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            width: 90%; /* Make it reasonably wide */
            max-width: 340px;
        }
        #fullscreenBtn:hover {
            background-color: #8A2BE2;
        }
        canvas {
            border: 2px solid #4A0072; /* Dark purple border */
            display: block; /* Prevents extra space below canvas */
        }
        #controlsInfo {
            margin-top: 10px; /* Space above controls info, below canvas */
            padding: 10px;
            background-color: rgba(74, 0, 114, 0.8);
            border-radius: 5px;
            text-align: center;
            width: 90%; /* Ensure it fits well */
            max-width: 340px; /* Match canvas width or so */
        }
        #controlsInfo p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="fullscreenBtn">Go Fullscreen</button> <!-- MOVED HERE -->
        <canvas id="gameCanvas"></canvas>
        <div id="controlsInfo">
            <p><strong>Controls:</strong></p>
            <p>Left/Right Arrows: Move | Up Arrow/Space: Jump</p>
            <p>X: Place Block | C: Dash</p>
            <p id="blockCount">Blocks: 3</p>
            <p id="levelDisplay">Level: 1</p>
            <p id="messageDisplay"></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blockCountDisplay = document.getElementById('blockCount');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const gameContainer = document.getElementById('gameContainer');


        // Game dimensions
        // Adjusted gameHeight to account for button at the top and controls info at the bottom
        let gameWidth = 360;
        let gameHeight = 500; // Further adjusted if button and info take more space
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        // Game settings
        const gravity = 0.5;
        const playerSpeed = 3;
        const jumpStrength = -10;
        const dashSpeed = 8;
        const dashDuration = 150; // milliseconds
        const maxBlocks = 3;
        const blockWidth = 40;
        const blockHeight = 20;

        // Colors
        const groundColor = '#6A0DAD'; // Purple
        const playerColor = '#8A2BE2'; // BlueViolet
        const blockColor = '#9932CC'; // DarkOrchid
        const spikeColor = '#4B0082'; // Dark Purple (Indigo)
        const startColor = '#7FFF00'; // Chartreuse (Greenish)
        const goalColor = '#FFD700'; // Gold
        const gameBackgroundColor = '#E6E6FA'; // Light purple background for canvas drawing

        let player = {
            x: 50,
            y: gameHeight - 80, // Start above ground
            width: 30,
            height: 30,
            dx: 0,
            dy: 0,
            onGround: false,
            blocksAvailable: maxBlocks,
            isDashing: false,
            dashTimer: 0,
            dashDirection: 0 // 1 for right, -1 for left
        };

        let placedBlocks = [];
        let currentLevel = 1;
        let levels = []; // Array to hold level configurations

        let keys = {
            left: false,
            right: false,
            up: false
        };

        let ground, startZone, goalZone, spikes;

        function setupLevel(levelNumber) {
            player.x = 50;
            player.y = gameHeight - 80;
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
            player.blocksAvailable = maxBlocks;
            placedBlocks = [];
            messageDisplay.textContent = "";

            levels[0] = {
                groundY: gameHeight - 40,
                start: { x: 10, y: gameHeight - 70, width: 60, height: 30 },
                goal: { x: gameWidth - 70, y: gameHeight - 70, width: 60, height: 30 },
                spikes: [
                    { x: gameWidth / 2 - 20, y: gameHeight - 60, width: 40, height: 20 }
                ]
            };
            levels[1] = {
                groundY: gameHeight - 40,
                start: { x: 10, y: gameHeight - 70, width: 60, height: 30 },
                goal: { x: gameWidth - 70, y: 100, width: 60, height: 30 },
                spikes: [
                    { x: 100, y: gameHeight - 60, width: 40, height: 20 },
                    { x: 200, y: gameHeight - 120, width: 40, height: 20 }
                ]
            };

            if (levelNumber > 10 && levelNumber % 10 === 0) {
                 // More noticeable difficulty increase notification
                messageDisplay.textContent = `LEVEL ${levelNumber}! Getting MUCH harder!`;
            }


            const levelConfig = levels[(levelNumber - 1) % levels.length];
            ground = { x: 0, y: levelConfig.groundY, width: gameWidth, height: 40 };
            startZone = levelConfig.start;
            goalZone = levelConfig.goal;
            spikes = levelConfig.spikes;

            updateUI();
        }


        function rectCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function resetPlayer() {
            messageDisplay.textContent = "Ouch! Try again.";
            const levelConfig = levels[(currentLevel - 1) % levels.length];
            player.x = levelConfig.start.x + levelConfig.start.width / 2 - player.width / 2;
            player.y = levelConfig.start.y - player.height - 1;
            player.dx = 0;
            player.dy = 0;
            player.onGround = false;
        }

        function update() {
            if (player.isDashing) {
                player.dashTimer -= 1000 / 60;
                if (player.dashTimer <= 0) {
                    player.isDashing = false;
                    player.dx = 0;
                } else {
                    player.dx = player.dashDirection * dashSpeed;
                    player.dy = 0;
                }
            } else {
                player.dx = 0;
                if (keys.left) player.dx = -playerSpeed;
                if (keys.right) player.dx = playerSpeed;
            }

            player.x += player.dx;

            if (!player.isDashing) {
                player.dy += gravity;
                player.y += player.dy;
            }

            player.onGround = false;

            if (player.y + player.height > ground.y) {
                player.y = ground.y - player.height;
                player.dy = 0;
                player.onGround = true;
            }

            placedBlocks.forEach(block => {
                if (rectCollision(player, block)) {
                    if (player.dy > 0 && player.y + player.height - player.dy <= block.y) {
                        player.y = block.y - player.height;
                        player.dy = 0;
                        player.onGround = true;
                    } else if (player.dx > 0 && player.x + player.width - player.dx <= block.x) {
                        player.x = block.x - player.width;
                        player.dx = 0;
                    } else if (player.dx < 0 && player.x - player.dx >= block.x + block.width) {
                        player.x = block.x + block.width;
                        player.dx = 0;
                    }
                }
            });

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > gameWidth) player.x = gameWidth - player.width;

            spikes.forEach(spike => {
                if (rectCollision(player, spike)) {
                    resetPlayer();
                }
            });

            if (rectCollision(player, startZone)) {
                if (player.blocksAvailable < maxBlocks) {
                    player.blocksAvailable = maxBlocks;
                    messageDisplay.textContent = "Blocks Refilled!";
                    updateUI();
                }
            }

            if (rectCollision(player, goalZone)) {
                currentLevel++;
                // Clear previous message before setting new level message
                messageDisplay.textContent = "";
                // Temporary message for level change
                const tempMsg = `Level ${currentLevel}!`;
                messageDisplay.textContent = tempMsg;


                if (currentLevel > 10 && (currentLevel -1) % 10 === 0) {
                     messageDisplay.textContent = `Level ${currentLevel}! Difficulty Ramping Up!`;
                }
                // Use a timeout to show the level message briefly, then clear or setup level
                setTimeout(() => {
                    if (messageDisplay.textContent === tempMsg || messageDisplay.textContent.includes(`Level ${currentLevel}!`)) { // Avoid clearing "difficulty" message too soon
                        messageDisplay.textContent = ""; // Clear after a bit if no other specific message
                    }
                    setupLevel(currentLevel);
                }, 1500); // Show level message for 1.5s
            }

             if (player.y > canvas.height + player.height) { // Player fell completely off screen
                resetPlayer();
            }
        }

        function draw() {
            ctx.fillStyle = gameBackgroundColor;
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            ctx.fillStyle = groundColor;
            ctx.fillRect(ground.x, ground.y, ground.width, ground.height);

            ctx.fillStyle = startColor;
            ctx.fillRect(startZone.x, startZone.y, startZone.width, startZone.height);
            ctx.fillStyle = 'black';
            ctx.textAlign = 'center';
            ctx.fillText("START", startZone.x + startZone.width / 2, startZone.y + startZone.height / 2 + 5);

            ctx.fillStyle = goalColor;
            ctx.fillRect(goalZone.x, goalZone.y, goalZone.width, goalZone.height);
            ctx.fillStyle = 'black';
            ctx.fillText("GOAL", goalZone.x + goalZone.width / 2, goalZone.y + goalZone.height / 2 + 5);

            ctx.fillStyle = spikeColor;
            spikes.forEach(spike => {
                ctx.beginPath();
                ctx.moveTo(spike.x, spike.y + spike.height);
                ctx.lineTo(spike.x + spike.width / 2, spike.y);
                ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
                ctx.closePath();
                ctx.fill();
            });

            ctx.fillStyle = blockColor;
            placedBlocks.forEach(block => {
                ctx.fillRect(block.x, block.y, block.width, block.height);
            });

            ctx.fillStyle = player.isDashing ? '#FF69B4' : playerColor;
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        function updateUI() {
            blockCountDisplay.textContent = `Blocks: ${player.blocksAvailable}`;
            levelDisplay.textContent = `Level: ${currentLevel}`;
        }

        function placeBlock() {
            if (player.blocksAvailable > 0) {
                placedBlocks.push({
                    x: player.x + (player.width / 2) - (blockWidth / 2),
                    y: player.y + player.height,
                    width: blockWidth,
                    height: blockHeight
                });
                player.blocksAvailable--;
                updateUI();
            } else {
                messageDisplay.textContent = "Out of blocks!";
                setTimeout(() => { if(messageDisplay.textContent === "Out of blocks!") messageDisplay.textContent = ""; }, 1500);
            }
        }

        function performDash() {
            if (!player.isDashing) {
                player.isDashing = true;
                player.dashTimer = dashDuration;
                if (keys.left) player.dashDirection = -1;
                else if (keys.right) player.dashDirection = 1;
                else player.dashDirection = (player.x < gameWidth / 2 ? 1 : -1);
                if (player.dashDirection === 0) player.dashDirection = 1;
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', function(e) {
            if (document.activeElement === fullscreenBtn && e.key === 'Enter') { // Allow activating button with Enter
                 if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                    openFullscreen(gameContainer);
                } else {
                    closeFullscreen();
                }
                return; // Prevent game actions if interacting with button
            }

            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === ' ') {
                e.preventDefault(); // Prevent space from scrolling page
                keys.up = true;
                if (player.onGround && !player.isDashing) {
                    player.dy = jumpStrength;
                    player.onGround = false;
                }
            }
            if (e.key === 'x' || e.key === 'X') {
                placeBlock();
            }
            if (e.key === 'c' || e.key === 'C') {
                performDash();
            }
        });

        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === ' ') keys.up = false;
        });

        // --- Fullscreen API Logic ---
        function openFullscreen(elem) {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.mozRequestFullScreen) { /* Firefox */
                elem.mozRequestFullScreen();
            } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE/Edge */
                elem.msRequestFullscreen();
            }
        }

        function closeFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) { /* Firefox */
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) { /* Chrome, Safari and Opera */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE/Edge */
                document.msExitFullscreen();
            }
        }

        fullscreenBtn.addEventListener('click', function() {
            if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                openFullscreen(gameContainer);
            } else {
                closeFullscreen();
            }
        });

        function updateFullscreenButtonText() {
            if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                fullscreenBtn.textContent = "Exit Fullscreen";
            } else {
                fullscreenBtn.textContent = "Go Fullscreen";
            }
        }

        document.addEventListener('fullscreenchange', updateFullscreenButtonText);
        document.addEventListener('mozfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButtonText);
        document.addEventListener('msfullscreenchange', updateFullscreenButtonText);

        // Initial setup
        setupLevel(currentLevel);
        updateFullscreenButtonText(); // Set initial button text
        gameLoop();
    </script>
</body>
</html>
