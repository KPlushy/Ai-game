        // ... (Keep all your existing code before this function)

        function generateProceduralLevel(levelNumber) {
            const effectiveLevelNum = levelNumber - numDefinedLevels;
            const currentLevelActualWidth = gameWidth * (2.5 + Math.floor(effectiveLevelNum / 3));
            levelActualWidth = Math.min(currentLevelActualWidth, gameWidth * 10); // Max level width
            let config = {
                name: `Procedural Lvl ${levelNumber}`,
                messageOnLoad: `Level ${levelNumber}: Survive!`,
                levelActualWidth: levelActualWidth,
                groundSegments: [],
                startZone: { x: 30 + Math.random() * 20, y: gameHeight - 70, width: 60, height: 30 }, // Initial temporary values
                goalZone: { x: levelActualWidth - 90 - Math.random() * 30, y: gameHeight - 70, width: 60, height: 30 }, // Initial temporary values
                spikes: [],
                enemies: [],
                powerUps: []
            };

            // 1. Generate Ground Segments
            let currentX = 0;
            let lastPlatformY = gameHeight - 40;
            const minPlatformWidth = 70;
            const maxPlatformWidth = gameWidth * 0.6;
            const maxMainGapWidth = playerBaseWidth * 2 + blockWidth; // Max gap traversable with some help
            const maxYVariation = 150;
            let platformCount = 0;

            while (currentX < config.levelActualWidth) {
                let platformWidth = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
                platformWidth = Math.min(platformWidth, config.levelActualWidth - currentX); // Don't overshoot level width
                let platformY = lastPlatformY;
                if (platformCount > 0 && Math.random() < 0.7) { // Vary Y for subsequent platforms
                    platformY = (gameHeight - 60 - maxYVariation / 2) + (Math.random() * maxYVariation);
                    platformY = Math.max(gameHeight - 250, Math.min(gameHeight - 30, platformY)); // Clamp Y
                }
                let currentPlatform = { x: currentX, y: platformY, width: platformWidth, height: gameHeight - platformY, isSkyIsland: false };
                config.groundSegments.push(currentPlatform);
                currentX += platformWidth;
                lastPlatformY = platformY;
                platformCount++;

                // Chance to spawn a sky island above the current main platform
                if (Math.random() < 0.25 + effectiveLevelNum * 0.02) { // More islands on higher levels
                    let islandX = currentPlatform.x + (Math.random() * (currentPlatform.width - 60)); // Ensure island fits on platform
                    islandX = Math.max(currentPlatform.x + 10, islandX);
                    let islandY = currentPlatform.y - 60 - (Math.random() * 120); // Above current platform
                    islandY = Math.max(60, islandY); // Not too high
                    let islandW = 50 + Math.random() * 80;
                    let islandH = 20 + Math.random() * 10;
                    if (islandX + islandW < config.levelActualWidth) { // Check bounds
                        config.groundSegments.push({ x: islandX, y: islandY, width: islandW, height: islandH, isSkyIsland: true });
                    }
                }

                if (currentX < config.levelActualWidth - maxPlatformWidth) { // Add a gap if not near the end
                    let gapWidth = (playerBaseWidth + 10) + Math.random() * (maxMainGapWidth - (playerBaseWidth + 10));
                    currentX += gapWidth;
                }
            }
            if (config.groundSegments.length === 0) { // Safety net: ensure at least one platform
                config.groundSegments.push({ x: 0, y: gameHeight - 40, width: config.levelActualWidth, height: 40, isSkyIsland: false });
            }

            // 2. Generate Spikes
            const numSpikesToGenerate = levelNumber; // More spikes for higher levels
            let spikeW = Math.max(5, 25 - Math.floor(levelNumber / 4)); // Spikes get thinner
            const spikeH = 20;
            for (let i = 0; i < numSpikesToGenerate; i++) {
                let sX, sY;
                if (config.groundSegments.length > 0 && Math.random() < 0.8) { // Place on existing platforms most of the time
                    let platform = config.groundSegments[Math.floor(Math.random() * config.groundSegments.length)];
                    sX = platform.x + (Math.random() * (platform.width - spikeW)); // Ensure spike fits on platform
                    if (Math.random() < 0.7 || platform.isSkyIsland) { // On top
                        sY = platform.y - spikeH;
                    } else { // Floating spike below platform (less common)
                        sY = platform.y - spikeH - 10 - (Math.random() * 80);
                    }
                } else { // Randomly in space (less common)
                    sX = Math.random() * (config.levelActualWidth - spikeW);
                    sY = 60 + Math.random() * (gameHeight - 120 - spikeH);
                }
                sX = Math.max(0, Math.min(sX, config.levelActualWidth - spikeW));
                sY = Math.max(20, sY); // Keep spikes above a certain y-level
                config.spikes.push({ x: sX, y: sY, width: spikeW, height: spikeH });
            }

            // 3. Place Start Zone (with validation)
            const firstPlatform = config.groundSegments.find(p => !p.isSkyIsland) || config.groundSegments[0];
            if (firstPlatform) {
                let startZoneValid = false;
                let startAttempts = 0;
                const maxStartAttempts = 25;
                while (!startZoneValid && startAttempts < maxStartAttempts) {
                    config.startZone.y = firstPlatform.y - config.startZone.height - 1;
                    config.startZone.x = firstPlatform.x + 5 + Math.random() * (firstPlatform.width - config.startZone.width - 10);
                    config.startZone.x = Math.max(firstPlatform.x + 5, config.startZone.x);
                    config.startZone.x = Math.min(firstPlatform.x + firstPlatform.width - config.startZone.width - 5, config.startZone.x);

                    const isOverlappingSpike = config.spikes.some(spike => rectCollision(config.startZone, spike));
                    const isOverlappingOtherGround = config.groundSegments.some(gs => gs !== firstPlatform && rectCollision(config.startZone, gs));
                    
                    startZoneValid = !isOverlappingSpike && !isOverlappingOtherGround;
                    startAttempts++;
                }
                if (!startZoneValid) { // Fallback
                    config.startZone.x = firstPlatform.x + 5;
                    config.startZone.y = firstPlatform.y - config.startZone.height - 1;
                    // console.warn(`Lvl ${levelNumber}: Could not place start zone safely after ${maxStartAttempts} attempts. Using fallback.`);
                }
            } else { // Should not happen if groundSegments safety net works
                 config.startZone.y = gameHeight - 70;
                 config.startZone.x = 30;
            }


            // 4. Place Goal Zone (with validation)
            let potentialGoalPlatforms = config.groundSegments.filter(p => p.x > config.levelActualWidth * 0.65); // From latter part of level
            let goalPlatformForPlacement = null;
            if (potentialGoalPlatforms.length > 0) {
                goalPlatformForPlacement = potentialGoalPlatforms.find(p => p.isSkyIsland && p.y < gameHeight - 100 && p.width >= config.goalZone.width); // Prefer a reachable sky island
                if (!goalPlatformForPlacement) {
                    goalPlatformForPlacement = potentialGoalPlatforms.sort((a,b) => b.x - a.x)[0]; // Furthest platform otherwise
                }
            }
            if (!goalPlatformForPlacement && config.groundSegments.length > 0) {
                goalPlatformForPlacement = config.groundSegments[config.groundSegments.length - 1]; // Absolute fallback: last platform
            }

            if (goalPlatformForPlacement) {
                let goalZoneValid = false;
                let goalAttempts = 0;
                const maxGoalAttempts = 30;
                let currentCandidatePlatform = goalPlatformForPlacement;
                let platformCandidates = potentialGoalPlatforms.length > 0 ? [...potentialGoalPlatforms] : [goalPlatformForPlacement]; // Create a copy
                let candidateIdx = platformCandidates.indexOf(currentCandidatePlatform);
                if(candidateIdx === -1) candidateIdx = 0;


                while (!goalZoneValid && goalAttempts < maxGoalAttempts && platformCandidates.length > 0) {
                    currentCandidatePlatform = platformCandidates[candidateIdx];
                    if (!currentCandidatePlatform) { // Should not happen if candidates list is managed
                        goalAttempts = maxGoalAttempts; break;
                    }

                    config.goalZone.y = currentCandidatePlatform.y - config.goalZone.height - 1;
                    let centerX = currentCandidatePlatform.x + (currentCandidatePlatform.width / 2) - (config.goalZone.width / 2);
                    config.goalZone.x = centerX + (Math.random() - 0.5) * (currentCandidatePlatform.width * 0.2); // Small random shift
                    config.goalZone.x = Math.max(currentCandidatePlatform.x + 5, config.goalZone.x);
                    config.goalZone.x = Math.min(currentCandidatePlatform.x + currentCandidatePlatform.width - config.goalZone.width - 5, config.goalZone.x);

                    const isOverlappingSpike = config.spikes.some(spike => rectCollision(config.goalZone, spike));
                    const isOverlappingOtherGround = config.groundSegments.some(gs => gs !== currentCandidatePlatform && rectCollision(config.goalZone, gs));

                    goalZoneValid = !isOverlappingSpike && !isOverlappingOtherGround;

                    if (!goalZoneValid && platformCandidates.length > 1 && (goalAttempts % 5 === 4 || goalAttempts === maxGoalAttempts -1) ) { // Try new platform every 5 attempts or last try
                        platformCandidates.splice(candidateIdx, 1); // Remove current failing candidate
                        if (platformCandidates.length > 0) {
                            candidateIdx = Math.floor(Math.random() * platformCandidates.length); // Pick a new random one
                        } else {
                             break; // No more candidates
                        }
                    }
                    goalAttempts++;
                }

                if (!goalZoneValid) { // Fallback if all attempts on all candidates fail
                    let fallbackPlatform = goalPlatformForPlacement || config.groundSegments[config.groundSegments.length - 1];
                    config.goalZone.y = fallbackPlatform.y - config.goalZone.height - 1;
                    config.goalZone.x = fallbackPlatform.x + (fallbackPlatform.width / 2) - (config.goalZone.width / 2);
                    // console.warn(`Lvl ${levelNumber}: Could not place goal zone safely after ${maxGoalAttempts} attempts. Using fallback.`);
                }
            } else { // Should not happen
                config.goalZone.y = gameHeight - 70;
                config.goalZone.x = config.levelActualWidth - 90;
            }


            // 5. Generate Enemies
            const numEnemies = Math.min(10, Math.floor(effectiveLevelNum / 2.5)); // Slightly adjusted enemy scaling
            for (let i = 0; i < numEnemies; i++) {
                let groundPlatforms = config.groundSegments.filter(p => (!p.isSkyIsland || p.width > 60) && p.width >= 40); // Suitable platforms for enemies
                if (groundPlatforms.length > 0) {
                    let platform = groundPlatforms[Math.floor(Math.random() * groundPlatforms.length)];
                    let eX = platform.x + 20 + Math.random() * (platform.width - 40); // Position within platform
                    let eY = platform.y - 20; // Enemy height is 20
                    let newEnemy = { x: eX, y: eY, type: 'shooter', width: 20, height: 20, shootCooldown: 180 - Math.min(120, effectiveLevelNum * 3), shootTimer: Math.random() * 60 };
                    // Ensure enemy is not in start/goal
                    if (!rectCollision(newEnemy, config.startZone) && !rectCollision(newEnemy, config.goalZone)) {
                        config.enemies.push(newEnemy);
                    }
                }
            }

            // 6. Generate Power-ups
            if (Math.random() < 0.4 + Math.min(0.2, effectiveLevelNum * 0.01)) { // Chance for a power-up
                let powerUpType = Math.random() < 0.5 ? 'blockBerry' : 'speedBerry';
                let pX, pY;
                let attempts = 0;
                let placed = false;
                while (!placed && attempts < 20) {
                    let skyIslands = config.groundSegments.filter(p => p.isSkyIsland && p.y < gameHeight - 150 && p.width >= powerUpSize && p.height >= powerUpSize);
                    if (skyIslands.length > 0 && Math.random() < 0.7) { // Prefer placing on sky islands
                        let island = skyIslands[Math.floor(Math.random() * skyIslands.length)];
                        pX = island.x + (island.width / 2) - (powerUpSize / 2);
                        pY = island.y - powerUpSize - 5; // Slightly above island
                    } else { // Random placement if no suitable island or by chance
                        pX = config.startZone.x + config.startZone.width + 50 + Math.random() * (config.levelActualWidth - 150 - config.startZone.x - config.startZone.width);
                        pY = 60 + Math.random() * (gameHeight - 250);
                    }
                    let tempPowerUpRect = { x: pX, y: pY, width: powerUpSize, height: powerUpSize };
                    // Check collisions
                    if (!rectCollision(tempPowerUpRect, config.startZone) &&
                        !rectCollision(tempPowerUpRect, config.goalZone) &&
                        !config.spikes.some(s => rectCollision(tempPowerUpRect, s)) &&
                        !config.groundSegments.some(gs => rectCollision(tempPowerUpRect, gs) && (tempPowerUpRect.y + tempPowerUpRect.height > gs.y)) // Not inside ground
                        ) {
                        placed = true;
                    }
                    attempts++;
                }
                if (placed) {
                    config.powerUps.push({ x: pX, y: pY, type: powerUpType, collected: false, width: powerUpSize, height: powerUpSize });
                }
            }

            // Final message adjustments
            if (levelNumber > 60) config.messageOnLoad = `Lvl ${levelNumber}: Unforgiving!`;
            else if (levelNumber > 35) config.messageOnLoad = `Lvl ${levelNumber}: Hostile Territory!`;

            // REMOVED: config.spikes = config.spikes.filter(s => !(rectCollision(s, config.startZone) || rectCollision(s, config.goalZone)));
            // Spikes are now filtered during their own generation or by zone placement logic.
            // Enemies are already filtered during their generation not to be in start/goal.

            return config;
        }

        // ... (Rest of your existing code)
