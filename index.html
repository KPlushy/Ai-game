<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML Parkour - Power-ups!</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #301934; font-family: Arial, sans-serif; color: white; -webkit-user-select: none; -ms-user-select: none; user-select: none; }
        #gameContainer { display: flex; flex-direction: column; align-items: center; background-color: #E6E6FA; padding: 10px; box-sizing: border-box; border-radius: 8px; position: relative; }
        #fullscreenBtn { margin-bottom: 10px; padding: 8px 15px; background-color: #6A0DAD; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; width: 90%; max-width: 340px; }
        #fullscreenBtn:hover { background-color: #8A2BE2; }
        canvas { border: 2px solid #4A0072; display: block; }
        #controlsInfo { margin-top: 10px; padding: 10px; background-color: rgba(74, 0, 114, 0.8); border-radius: 5px; text-align: center; width: 90%; max-width: 340px; }
        #controlsInfo p { margin: 5px 0; }
        #messageDisplay { min-height: 1.2em; font-weight: bold; }
        #powerUpStatus { font-size: 0.9em; color: #FFD700; min-height: 1em; margin-top: 3px;}


        #mobileControls { position: fixed; bottom: 0; left: 0; width: 100%; padding: 10px 5px; box-sizing: border-box; display: none; justify-content: space-between; align-items: flex-end; z-index: 100; background-color: rgba(0,0,0,0.1); }
        .mobile-btn-group { display: flex; gap: 5px; }
        .mobile-btn { padding: 15px; font-size: 1.2em; background-color: rgba(106, 13, 173, 0.7); color: white; border: 2px solid rgba(74, 0, 114, 0.9); border-radius: 8px; cursor: pointer; min-width: 60px; text-align: center; -webkit-tap-highlight-color: transparent; }
        .mobile-btn:active { background-color: rgba(138, 43, 226, 0.8); }
        #mobileControls .right-controls { flex-direction: column; align-items: flex-end; }
        #mobileControls .action-buttons-row1, #mobileControls .action-buttons-row2 { display: flex; gap: 5px; margin-bottom: 5px;}
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="fullscreenBtn">Go Fullscreen</button>
        <canvas id="gameCanvas"></canvas>
        <div id="controlsInfo">
            <p><strong>Controls (Keyboard):</strong></p>
            <p>Left/Right Arrows: Move | Up Arrow/Space: Jump</p>
            <p>X: Place Block | C: Dash</p>
            <p id="blockCount">Blocks: 3</p>
            <p id="levelDisplay">Level: 1</p>
            <p id="deathCountDisplay">Deaths: 0</p>
            <p id="powerUpStatus"></p> {/* For displaying power-up status */}
            <p id="messageDisplay"></p>
        </div>
    </div>
    <div id="mobileControls"> /* ... mobile controls HTML ... */ </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); /* ... other consts ... */
        const powerUpStatusDisplay = document.getElementById('powerUpStatus');
        // ... (all other consts from previous code)

        let gameWidth = 360; let gameHeight = 500; /* ... */
        let levelActualWidth = gameWidth;

        const gravity = 0.5; /* ... other game settings ... */
        const dashCooldownTime = 30; // 0.5 seconds
        const powerUpDuration = 600; // 10 seconds * 60 FPS

        /* ... colors ... */
        const blockBerryColor = '#FF69B4'; // Hot Pink
        const speedBerryColor = '#00FFFF'; // Aqua

        let player = { /* ... */ dashCooldownTimer: 0 };
        let camera = { x: 0, y: 0 };
        let placedBlocks = []; let currentLevel = 1; let isLevelTransitioning = false;
        let keys = { left: false, right: false, up: false };
        let deathCount = 0;

        let groundSegments = []; let startZone, goalZone, spikes;
        let enemies = []; let projectiles = [];
        let levelPowerUps = []; // Holds power-ups for the current level {x,y,w,h,type,collected}
        let activePlayerPowerUps = {
            blockBerry: { active: false, timer: 0, duration: powerUpDuration },
            speedBerry: { active: false, timer: 0, duration: powerUpDuration }
        };

        const definedLevels = [ /* ... Ensure these levels now have an empty powerUps: [] array if none are intended ... */
            { name: "Horizontal Scroll!", messageOnLoad: "Welcome!", levelActualWidth: gameWidth * 1.5, groundSegments: [ { x: 0, y: gameHeight - 40, width: gameWidth * 1.5, height: 40 } ], startZone: { x: 30, y: gameHeight - 70, width: 60, height: 30 }, goalZone: { x: gameWidth * 1.5 - 90, y: gameHeight - 70, width: 60, height: 30 }, spikes: [ { x: gameWidth * 0.75 - 15, y: gameHeight - 60, width: 30, height: 20 } ], enemies: [], powerUps: [{x: gameWidth * 0.5, y: gameHeight - 150, type: 'speedBerry'}] },
            { name: "Gaps and Platforms", messageOnLoad: "Watch your step!", levelActualWidth: gameWidth * 2, groundSegments: [ { x: 0, y: gameHeight - 40, width: gameWidth * 0.4, height: 40 }, { x: gameWidth * 0.5, y: gameHeight - 60, width: gameWidth * 0.3, height: 60 }, { x: gameWidth * 0.9, y: gameHeight - 40, width: gameWidth * 0.4, height: 40 }, { x: gameWidth * 1.5, y: gameHeight - 50, width: gameWidth * 0.5, height: 50 } ], startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 }, goalZone: { x: gameWidth * 2 - 100, y: gameHeight - 80, width: 60, height: 30 }, spikes: [ { x: gameWidth * 0.4 + 10, y: gameHeight - 20, width: gameWidth*0.1-20, height: 20}, { x: gameWidth * 0.6, y: gameHeight - 80, width: 30, height: 20 }, { x: gameWidth * 1.2, y: gameHeight - 20, width: gameWidth*0.3-20, height:20 } ], enemies: [{x: gameWidth * 0.55, y: gameHeight - 80 - 20, type: 'shooter', width:20, height:20, shootCooldown:150}], powerUps: [] },
            { name: "Block Challenge", messageOnLoad: "Use blocks!", levelActualWidth: gameWidth * 2.5, groundSegments: [ { x: 0, y: gameHeight - 40, width: gameWidth * 0.6, height: 40 }, { x: gameWidth * 1.2, y: gameHeight - 40, width: gameWidth * 1.3, height: 40 } ], startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 }, goalZone: { x: gameWidth * 2.5 - 100, y: gameHeight - 70, width: 60, height: 30 }, spikes: [ { x: gameWidth * 1.5, y: gameHeight - 60, width: 30, height: 20 } ], enemies: [{x: gameWidth * 1.3, y: gameHeight - 60 - 20, type: 'shooter', width:20, height:20, shootCooldown:140}], powerUps: [{x: gameWidth * 0.8, y: gameHeight - 180, type: 'blockBerry'}] },
            // ... (other defined levels with powerUps: [] or specific placements)
        ];
        const numDefinedLevels = definedLevels.length;

        function generateProceduralLevel(levelNumber) {
            const effectiveLevelNum = levelNumber - numDefinedLevels; /* ... */
            let config = { /* ... name, message, width ... */
                groundSegments: [], startZone: { /* ... */ }, goalZone: { /* ... */ },
                spikes: [], enemies: [], powerUps: [] // Initialize powerUps array
            };

            /* ... Procedural Ground & Sky Island Generation (same as before) ... */
            let currentX = 0; /* ... */
            while (currentX < config.levelActualWidth) { /* ... */
                 // Inside ground/sky island loop, after a platform is made:
                if (Math.random() < 0.05 + effectiveLevelNum * 0.001) { // Chance to spawn a power-up on this platform
                    let pX = currentX - platformWidth + (Math.random() * (platformWidth - 20)); // On the platform just made
                     if (config.groundSegments.length > 0) { // Ensure there's a segment to get Y from
                        let parentPlatform = config.groundSegments[config.groundSegments.length -1];
                        let pY = parentPlatform.y - 25 - (Math.random() * 50); // Above platform
                        pY = Math.max(40, pY); // Keep on screen
                        let pType = Math.random() < 0.5 ? 'blockBerry' : 'speedBerry';
                        config.powerUps.push({x: pX, y: pY, width: 20, height: 20, type: pType, collected: false});
                    }
                }
                 /* ... rest of ground gen ... */
            }
            /* ... Procedural Spike and Enemy Generation (same as before) ... */

            // Ensure power-ups aren't overlapping spikes badly (simple check)
            config.powerUps.forEach(p => {
                config.spikes.forEach(s => {
                    if (rectCollision(p,s)) { // If powerup is inside a spike, try to move powerup up
                        p.y = s.y - p.height - 5;
                    }
                });
            });
            if (levelNumber > 70) { /* ... TAS messages ... */ }
            return config;
        }

        function setupLevel(levelNumber) {
            /* ... */
            activePlayerPowerUps.blockBerry = { active: false, timer: 0, duration: powerUpDuration };
            activePlayerPowerUps.speedBerry = { active: false, timer: 0, duration: powerUpDuration };
            levelPowerUps = []; // Clear existing powerups

            /* ... load levelConfig (defined or procedural) ... */
             if (levelConfig.powerUps) { // Load powerups from config
                levelPowerUps = levelConfig.powerUps.map(p => ({...p, collected: false, width: p.width || 20, height: p.height || 20}));
            }
            /* ... rest of setupLevel ... */
            updatePowerUpStatusDisplay(); // Update display
        }

        function rectCollision(rect1, rect2) { /* ... same ... */ }
        function resetPlayer() {
            deathCount++;
            activePlayerPowerUps.blockBerry = { active: false, timer: 0, duration: powerUpDuration }; // Reset powerups on death
            activePlayerPowerUps.speedBerry = { active: false, timer: 0, duration: powerUpDuration };
            /* ... rest of resetPlayer ... */
            updatePowerUpStatusDisplay(); // Update display
        }

        function updatePowerUpStatusDisplay() {
            let statusText = "";
            if (activePlayerPowerUps.blockBerry.active) {
                statusText += `Inf Blocks: ${(activePlayerPowerUps.blockBerry.timer / 60).toFixed(1)}s `;
            }
            if (activePlayerPowerUps.speedBerry.active) {
                statusText += `Fast Dash: ${(activePlayerPowerUps.speedBerry.timer / 60).toFixed(1)}s`;
            }
            powerUpStatusDisplay.textContent = statusText;
        }


        function update() {
            if (isLevelTransitioning) return;
            if (player.dashCooldownTimer > 0 && !activePlayerPowerUps.speedBerry.active) player.dashCooldownTimer--;

            // Update active power-up timers
            if (activePlayerPowerUps.blockBerry.active) {
                activePlayerPowerUps.blockBerry.timer--;
                if (activePlayerPowerUps.blockBerry.timer <= 0) activePlayerPowerUps.blockBerry.active = false;
            }
            if (activePlayerPowerUps.speedBerry.active) {
                activePlayerPowerUps.speedBerry.timer--;
                if (activePlayerPowerUps.speedBerry.timer <= 0) activePlayerPowerUps.speedBerry.active = false;
            }
            updatePowerUpStatusDisplay(); // Update display every frame

            /* ... Player movement, ground/block/spike collision (same as before) ... */

            // Power-up Collection
            for (let i = levelPowerUps.length - 1; i >= 0; i--) {
                let pUp = levelPowerUps[i];
                if (!pUp.collected && rectCollision(player, pUp)) {
                    pUp.collected = true;
                    if (pUp.type === 'blockBerry') {
                        activePlayerPowerUps.blockBerry.active = true;
                        activePlayerPowerUps.blockBerry.timer = activePlayerPowerUps.blockBerry.duration;
                        messageDisplay.textContent = "Infinite Blocks!";
                    } else if (pUp.type === 'speedBerry') {
                        activePlayerPowerUps.speedBerry.active = true;
                        activePlayerPowerUps.speedBerry.timer = activePlayerPowerUps.speedBerry.duration;
                        player.dashCooldownTimer = 0; // Immediately allow dash
                        messageDisplay.textContent = "Fast Dash!";
                    }
                    setTimeout(() => { if(messageDisplay.textContent.includes("Infinite Blocks!") || messageDisplay.textContent.includes("Fast Dash!")) messageDisplay.textContent = ""; }, 2000);
                }
            }


            /* ... Enemy Update & Shooting (same) ... */
            /* ... Projectile Update & Collision (projectiles pass through walls - no ground/block collision) ... */
            /* ... Start/Goal Zones (same) ... */
            /* ... Camera Update (same) ... */
        }

        function draw() {
            /* ... Clear canvas, translate camera ... */
            /* ... Draw Ground, Start/Goal, Spikes ... */

            // Draw Power-ups
            levelPowerUps.forEach(pUp => {
                if (!pUp.collected) {
                    if (pUp.type === 'blockBerry') ctx.fillStyle = blockBerryColor;
                    else if (pUp.type === 'speedBerry') ctx.fillStyle = speedBerryColor;
                    else ctx.fillStyle = 'gray'; // Fallback for unknown type
                    ctx.fillRect(pUp.x, pUp.y, pUp.width || 20, pUp.height || 20); // Default size if not specified
                    // Simple "B" or "S" text on powerup
                    ctx.fillStyle = "white"; ctx.font = "12px Arial"; ctx.textAlign = "center";
                    let text = pUp.type === 'blockBerry' ? "B" : (pUp.type === 'speedBerry' ? "S" : "?");
                    ctx.fillText(text, pUp.x + (pUp.width || 20)/2, pUp.y + (pUp.height || 20)/2 + 4);
                }
            });

            /* ... Draw Enemies, Projectiles, Placed Blocks, Player ... */
            /* ... ctx.restore() ... */
        }

        function updateUI() {
            if (activePlayerPowerUps.blockBerry.active) {
                blockCountDisplay.textContent = `Blocks: ∞`;
            } else {
                blockCountDisplay.textContent = `Blocks: ${player.blocksAvailable}`;
            }
            levelDisplay.textContent = `Level: ${currentLevel}`;
            deathCountDisplay.textContent = `Deaths: ${deathCount}`;
        }

        function placeBlock() {
            if (activePlayerPowerUps.blockBerry.active || player.blocksAvailable > 0) {
                placedBlocks.push({ x: player.x + (player.width / 2) - (blockWidth / 2), y: player.y + player.height, width: blockWidth, height: blockHeight });
                if (!activePlayerPowerUps.blockBerry.active) {
                    player.blocksAvailable--;
                }
                updateUI();
            } else {
                messageDisplay.textContent = "Out of blocks!";
                setTimeout(() => { if(messageDisplay.textContent === "Out of blocks!") messageDisplay.textContent = ""; }, 1500);
            }
        }

        function performDash() {
            if (player.isDashing) return;
            if (!activePlayerPowerUps.speedBerry.active && player.dashCooldownTimer > 0) {
                 messageDisplay.textContent = `Dash CD: ${(player.dashCooldownTimer/60).toFixed(1)}s`;
                 setTimeout(() => { if(messageDisplay.textContent.startsWith("Dash CD:")) messageDisplay.textContent = ""; }, 700);
                return;
            }

            player.isDashing = true; player.dashTimer = dashDuration;
            if (!activePlayerPowerUps.speedBerry.active) { // Only set cooldown if speed berry isn't active
                player.dashCooldownTimer = dashCooldownTime;
            }
            // ... (rest of dash direction logic)
            if (keys.left) player.dashDirection = -1;
            else if (keys.right) player.dashDirection = 1;
            else player.dashDirection = (player.x - camera.x < gameWidth / 2 ? 1 : -1); // Dash based on screen half
            if (player.dashDirection === 0) player.dashDirection = 1;
        }

        // ... gameLoop, Keyboard Listeners, Fullscreen Logic, Mobile Controls Setup ...
        // (Make sure mobile controls are set up as in the previous version)

        // Initial Setup
        setupLevel(currentLevel);
        updateFullscreenButtonText();
        updateUI();
        gameLoop();
    </script>
</body>
</html>
