<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HTML Horizontal Parkour</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #301934; font-family: Arial, sans-serif; color: white; }
        #gameContainer { display: flex; flex-direction: column; align-items: center; background-color: #E6E6FA; padding: 10px; box-sizing: border-box; border-radius: 8px; }
        #fullscreenBtn { margin-bottom: 10px; padding: 8px 15px; background-color: #6A0DAD; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; width: 90%; max-width: 340px; }
        #fullscreenBtn:hover { background-color: #8A2BE2; }
        canvas { border: 2px solid #4A0072; display: block; }
        #controlsInfo { margin-top: 10px; padding: 10px; background-color: rgba(74, 0, 114, 0.8); border-radius: 5px; text-align: center; width: 90%; max-width: 340px; }
        #controlsInfo p { margin: 5px 0; }
        #messageDisplay { min-height: 1.2em; font-weight: bold; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="fullscreenBtn">Go Fullscreen</button>
        <canvas id="gameCanvas"></canvas>
        <div id="controlsInfo">
            <p><strong>Controls:</strong></p>
            <p>Left/Right Arrows: Move | Up Arrow/Space: Jump</p>
            <p>X: Place Block | C: Dash</p>
            <p id="blockCount">Blocks: 3</p>
            <p id="levelDisplay">Level: 1</p>
            <p id="messageDisplay"></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const blockCountDisplay = document.getElementById('blockCount');
        const levelDisplay = document.getElementById('levelDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const gameContainer = document.getElementById('gameContainer');

        let gameWidth = 360; // Viewport width
        let gameHeight = 500; // Viewport height
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        let levelActualWidth = gameWidth; // Width of the entire level, can be larger than gameWidth

        const gravity = 0.5;
        const playerSpeed = 3.5; // Slightly faster for wider levels
        const jumpStrength = -11; // Slightly stronger jump
        const dashSpeed = 9;
        const dashDuration = 150;
        const maxBlocks = 3;
        const blockWidth = 40;
        const blockHeight = 20;
        const playerBaseWidth = 30;
        const playerBaseHeight = 30;

        const groundColor = '#6A0DAD';
        const playerColor = '#8A2BE2';
        const blockColor = '#9932CC';
        const spikeColor = '#4B0082';
        const startColor = '#7FFF00';
        const goalColor = '#FFD700';
        const gameBackgroundColor = '#E6E6FA'; // Light purple for sky

        let player = {
            x: 50, y: gameHeight - 80,
            width: playerBaseWidth, height: playerBaseHeight,
            dx: 0, dy: 0,
            onGround: false,
            blocksAvailable: maxBlocks,
            isDashing: false, dashTimer: 0, dashDirection: 0
        };

        let camera = {
            x: 0,
            y: 0 // For potential vertical scrolling later, not used now
        };

        let placedBlocks = [];
        let currentLevel = 1;
        let isLevelTransitioning = false;
        let keys = { left: false, right: false, up: false };

        let groundSegments = []; // Array of ground platform objects {x, y, width, height}
        let startZone, goalZone, spikes;

        const definedLevels = [
            { // Level 1
                name: "The First Step", messageOnLoad: "Horizontal Scroll!", levelActualWidth: gameWidth * 1.5,
                groundSegments: [ { x: 0, y: gameHeight - 40, width: gameWidth * 1.5, height: 40 } ],
                startZone: { x: 30, y: gameHeight - 70, width: 60, height: 30 },
                goalZone: { x: gameWidth * 1.5 - 90, y: gameHeight - 70, width: 60, height: 30 },
                spikes: [ { x: gameWidth * 0.75 - 15, y: gameHeight - 60, width: 30, height: 20 } ]
            },
            { // Level 2
                name: "Gaps and Platforms", messageOnLoad: "Watch your step!", levelActualWidth: gameWidth * 2,
                groundSegments: [
                    { x: 0, y: gameHeight - 40, width: gameWidth * 0.4, height: 40 },
                    { x: gameWidth * 0.5, y: gameHeight - 60, width: gameWidth * 0.3, height: 60 }, // Raised platform
                    { x: gameWidth * 0.9, y: gameHeight - 40, width: gameWidth * 0.4, height: 40 },
                    { x: gameWidth * 1.5, y: gameHeight - 50, width: gameWidth * 0.5, height: 50 }
                ],
                startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 },
                goalZone: { x: gameWidth * 2 - 100, y: gameHeight - 80, width: 60, height: 30 },
                spikes: [
                    { x: gameWidth * 0.4 + 10, y: gameHeight - 20, width: gameWidth*0.1-20, height: 20}, // Spike in gap
                    { x: gameWidth * 0.6, y: gameHeight - 80, width: 30, height: 20 },
                    { x: gameWidth * 1.2, y: gameHeight - 20, width: gameWidth*0.3-20, height:20 }
                ]
            },
            // Add 3 more simple defined levels for horizontal play
             { // Level 3
                name: "Block Challenge", messageOnLoad: "Use blocks to cross!", levelActualWidth: gameWidth * 2.5,
                groundSegments: [
                    { x: 0, y: gameHeight - 40, width: gameWidth * 0.6, height: 40 },
                    // Wide gap here, requiring blocks
                    { x: gameWidth * 1.2, y: gameHeight - 40, width: gameWidth * 1.3, height: 40 }
                ],
                startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 },
                goalZone: { x: gameWidth * 2.5 - 100, y: gameHeight - 70, width: 60, height: 30 },
                spikes: [
                     { x: gameWidth * 1.5, y: gameHeight - 60, width: 30, height: 20 }
                ]
            },
            { // Level 4
                name: "Floating Goals", messageOnLoad: "Reach for the sky!", levelActualWidth: gameWidth * 2,
                groundSegments: [
                    { x: 0, y: gameHeight - 40, width: gameWidth * 0.8, height: 40 },
                    { x: gameWidth * 1.2, y: gameHeight - 40, width: gameWidth * 0.8, height: 40 }
                ],
                startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 },
                goalZone: { x: gameWidth * 1.5, y: gameHeight - 200, width: 60, height: 30 }, // High goal
                spikes: [
                     { x: gameWidth * 0.5, y: gameHeight - 60, width: 30, height: 20 },
                     { x: gameWidth * 1.0, y: gameHeight - 20, width: gameWidth*0.2-20, height:20 }, // Gap Spike
                     { x: gameWidth * 1.5, y: gameHeight - 60, width: 30, height: 20 }
                ]
            },
            { // Level 5
                name: "Spike Gauntlet Intro", messageOnLoad: "Precision needed!", levelActualWidth: gameWidth * 3,
                groundSegments: [
                    { x: 0, y: gameHeight - 40, width: gameWidth*3, height: 40 } // Long flat ground for now
                ],
                startZone: { x: 50, y: gameHeight - 70, width: 60, height: 30 },
                goalZone: { x: gameWidth * 3 - 100, y: gameHeight - 70, width: 60, height: 30 },
                spikes: [
                    { x: 200, y: gameHeight - 60, width: 20, height: 20 }, { x: 230, y: gameHeight - 60, width: 20, height: 20 },
                    { x: 400, y: gameHeight - 80, width: 20, height: 20 }, { x: 430, y: gameHeight - 60, width: 20, height: 20 },
                    { x: 600, y: gameHeight - 60, width: 20, height: 20 }, { x: 630, y: gameHeight - 80, width: 20, height: 20 }, { x: 660, y: gameHeight - 60, width: 20, height: 20 },
                ]
            },
        ];
        const numDefinedLevels = definedLevels.length;

        function generateProceduralLevel(levelNumber) {
            const effectiveLevelNum = levelNumber - numDefinedLevels;
            const currentLevelActualWidth = gameWidth * (2 + Math.floor(effectiveLevelNum / 4)); // Level width increases
            levelActualWidth = Math.min(currentLevelActualWidth, gameWidth * 8); // Cap width

            let config = {
                name: `Procedural Lvl ${levelNumber}`,
                messageOnLoad: `Level ${levelNumber}: ${levelNumber} Spikes!`,
                levelActualWidth: levelActualWidth,
                groundSegments: [],
                startZone: { x: 30 + Math.random()*20, y: gameHeight - 70, width: 60, height: 30 }, // y relative to viewport bottom
                goalZone: { x: levelActualWidth - 90 - Math.random()*30, y: gameHeight - 70, width: 60, height: 30 },
                spikes: []
            };

            // --- Procedural Ground Generation ---
            let currentX = 0;
            let lastPlatformEndY = gameHeight - 40;
            const minPlatformWidth = 80;
            const maxPlatformWidth = gameWidth * 0.8;
            const maxGapWidth = playerBaseWidth * 3 + blockWidth; // Max jump/dash or block
            const maxYVariation = 120;

            while (currentX < config.levelActualWidth) {
                let platformWidth = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
                platformWidth = Math.min(platformWidth, config.levelActualWidth - currentX); // Don't overshoot

                let platformY = lastPlatformEndY;
                if (config.groundSegments.length > 0 && Math.random() < 0.6) { // Chance to change Y
                    platformY = (gameHeight - 40 - maxYVariation/2) + (Math.random() * maxYVariation);
                    platformY = Math.max(gameHeight - 200, Math.min(gameHeight - 30, platformY)); // Clamp Y
                }
                
                config.groundSegments.push({ x: currentX, y: platformY, width: platformWidth, height: gameHeight - platformY }); // Height goes to bottom
                currentX += platformWidth;
                lastPlatformEndY = platformY;

                if (currentX < config.levelActualWidth - maxPlatformWidth) { // Add a gap if not near end
                    let gapWidth = (playerBaseWidth + 5) + Math.random() * (maxGapWidth - (playerBaseWidth + 5));
                    currentX += gapWidth;
                }
            }
            // Ensure start and goal are on a platform (simplified: use first/last platform)
            if (config.groundSegments.length > 0) {
                config.startZone.y = config.groundSegments[0].y - config.startZone.height -1;
                config.goalZone.y = config.groundSegments[config.groundSegments.length-1].y - config.goalZone.height -1;
                 // Make sure goal X is on the last platform
                config.goalZone.x = Math.max(config.groundSegments[config.groundSegments.length-1].x + 20, config.goalZone.x);
                config.goalZone.x = Math.min(config.goalZone.x, config.groundSegments[config.groundSegments.length-1].x + config.groundSegments[config.groundSegments.length-1].width - config.goalZone.width - 5);

            } else { // Failsafe: create a single ground platform
                 config.groundSegments.push({x: 0, y: gameHeight - 40, width: config.levelActualWidth, height: 40});
                 config.startZone.y = gameHeight - 70;
                 config.goalZone.y = gameHeight - 70;
            }


            // --- Procedural Spike Generation ---
            const numSpikesToGenerate = levelNumber; // N spikes for level N
            let spikeW = Math.max(5, 30 - Math.floor(levelNumber / 3));
            const spikeH = 20;

            for (let i = 0; i < numSpikesToGenerate; i++) {
                let placedOnPlatform = false;
                let attempts = 0;
                while(!placedOnPlatform && attempts < 10){ // Try to place on a platform
                    let randomPlatformIndex = Math.floor(Math.random() * config.groundSegments.length);
                    let platform = config.groundSegments[randomPlatformIndex];
                    if (platform.width > spikeW + 10) { // Enough space on platform
                        let sX = platform.x + 5 + (Math.random() * (platform.width - spikeW - 10));
                        let sY = platform.y - spikeH; // On top of this platform

                        // Chance for floating spikes increases
                         if (levelNumber > 10 && Math.random() < (0.2 + Math.min(0.6, levelNumber * 0.02)) ) {
                             sY = platform.y - spikeH - (20 + Math.random() * 80);
                             sY = Math.max(40, sY); // Keep it on screen
                         }
                        config.spikes.push({ x: sX, y: sY, width: spikeW, height: spikeH });
                        placedOnPlatform = true;
                    }
                    attempts++;
                }
                if (!placedOnPlatform) { // Fallback: random placement (less ideal for playability)
                     let sX = 50 + Math.random() * (config.levelActualWidth - 100 - spikeW);
                     let sY = gameHeight - 40 - spikeH - (Math.random() * 100); // Mostly ground-ish or slightly floating
                     config.spikes.push({ x: sX, y: sY, width: spikeW, height: spikeH });
                }
            }

            // Adjust Goal Y for higher levels for more challenge
            if (levelNumber > numDefinedLevels + 5) {
                config.goalZone.y = Math.max(50, config.groundSegments[config.groundSegments.length-1].y - config.goalZone.height -1 - (Math.random() * Math.min(gameHeight * 0.4, (levelNumber-numDefinedLevels) * 5)));
            }

            if (levelNumber > 60) config.messageOnLoad = `Lvl ${levelNumber}: TAS Required!`;
            else if (levelNumber > 35) config.messageOnLoad = `Lvl ${levelNumber}: Brutal Density!`;
            else if (levelNumber > 20) config.messageOnLoad = `Lvl ${levelNumber}: Test Your Mettle!`;

            config.spikes = config.spikes.filter(s =>
                !(rectCollision(s, config.startZone) || rectCollision(s, config.goalZone))
            );
            return config;
        }


        function setupLevel(levelNumber) {
            isLevelTransitioning = false;
            player.dx = 0; player.dy = 0; player.onGround = false;
            player.blocksAvailable = maxBlocks; placedBlocks = [];

            let levelConfig;
            if (levelNumber <= numDefinedLevels) {
                const definedConfig = definedLevels[levelNumber - 1];
                levelConfig = JSON.parse(JSON.stringify(definedConfig)); // Deep copy
                messageDisplay.textContent = levelConfig.messageOnLoad || `Level ${levelNumber}: ${levelConfig.name || ''}`;
            } else {
                levelConfig = generateProceduralLevel(levelNumber);
                if (!messageDisplay.textContent && levelConfig.messageOnLoad) {
                    messageDisplay.textContent = levelConfig.messageOnLoad;
                } else if (!messageDisplay.textContent) {
                     messageDisplay.textContent = `Level ${levelNumber}: ${levelConfig.name || (levelNumber + " Spikes!")}`;
                }
            }

            levelActualWidth = levelConfig.levelActualWidth || gameWidth;
            groundSegments = levelConfig.groundSegments ? JSON.parse(JSON.stringify(levelConfig.groundSegments)) : [{x:0, y:gameHeight-40, width:levelActualWidth, height:40}];
            startZone = { ...(levelConfig.startZone || { x: 30, y: gameHeight - 70, width: 60, height: 30 }) };
            goalZone = { ...(levelConfig.goalZone || { x: levelActualWidth - 90, y: gameHeight - 70, width: 60, height: 30 }) };
            spikes = levelConfig.spikes ? JSON.parse(JSON.stringify(levelConfig.spikes)) : [];

            player.x = startZone.x; // Place player at start X
            player.y = startZone.y - player.height -1; // On top of start platform

            camera.x = Math.max(0, player.x - gameWidth / 4); // Initial camera pos
            camera.x = Math.min(camera.x, levelActualWidth - gameWidth);


            updateUI();
        }

        function rectCollision(rect1, rect2) {
            if (!rect1 || !rect2) return false;
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
        }

        function resetPlayer() {
            player.x = startZone.x;
            player.y = startZone.y - player.height - 1;
            player.dx = 0; player.dy = 0; player.onGround = false;
            camera.x = Math.max(0, player.x - gameWidth / 4);
            camera.x = Math.min(camera.x, levelActualWidth - gameWidth);
            messageDisplay.textContent = "Ouch! Try again.";
            setTimeout(() => { if(messageDisplay.textContent === "Ouch! Try again.") messageDisplay.textContent = ""; }, 1500);
        }

        function update() {
            if (isLevelTransitioning) return;

            // Player movement
            if (player.isDashing) { /* ... dash logic ... */ } else { /* ... normal move logic ... */ }
            // ... (Copy paste existing player move/dash/gravity logic here, then adapt for horizontal bounds)

            if (player.isDashing) {
                player.dashTimer -= 1000 / 60;
                if (player.dashTimer <= 0) { player.isDashing = false; player.dx = 0; }
                else { player.dx = player.dashDirection * dashSpeed; player.dy = 0; } // No Y move during dash
            } else {
                player.dx = 0;
                if (keys.left) player.dx = -playerSpeed;
                if (keys.right) player.dx = playerSpeed;
            }
            player.x += player.dx;

            // Horizontal world bounds
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > levelActualWidth) player.x = levelActualWidth - player.width;


            if (!player.isDashing) { player.dy += gravity; player.y += player.dy; }
            player.onGround = false;

            // Ground Collision (with segments)
            groundSegments.forEach(segment => {
                if (player.x + player.width > segment.x && player.x < segment.x + segment.width) { // Player is horizontally within segment
                    if (player.y + player.height >= segment.y && player.y + player.height - player.dy <= segment.y + 1) { // Coming from top
                        player.y = segment.y - player.height;
                        player.dy = 0;
                        player.onGround = true;
                    }
                }
            });

            // Placed Block Collision
            placedBlocks.forEach(block => {
                if (rectCollision(player, block)) {
                    if (player.dy > 0 && (player.y + player.height - player.dy) <= block.y + 1) {
                        player.y = block.y - player.height; player.dy = 0; player.onGround = true;
                    } // Add side collision for blocks if needed, careful with sticking
                }
            });

            // Spike Collision
            if (spikes) {
                spikes.forEach(spike => { if (rectCollision(player, spike)) resetPlayer(); });
            }

            // Start/Goal Zone Collision
            if (startZone && rectCollision(player, startZone)) {
                if (player.blocksAvailable < maxBlocks) {
                    player.blocksAvailable = maxBlocks;
                    messageDisplay.textContent = "Blocks Refilled!"; updateUI();
                    setTimeout(() => { if(messageDisplay.textContent === "Blocks Refilled!") messageDisplay.textContent = ""; }, 1500);
                }
            }
            if (goalZone && rectCollision(player, goalZone) && !isLevelTransitioning) {
                isLevelTransitioning = true; currentLevel++;
                // ... (message logic for advancing)
                let nextLevelName = "";
                if(currentLevel <= numDefinedLevels && definedLevels[currentLevel-1] && definedLevels[currentLevel-1].name){
                    nextLevelName = ": " + definedLevels[currentLevel-1].name;
                }
                messageDisplay.textContent = `Advancing to Level ${currentLevel}${nextLevelName}...`;
                setTimeout(() => { setupLevel(currentLevel); }, 1500); // Longer for wide levels
            }

            // Fall off screen
            if (player.y > gameHeight + player.height * 3) resetPlayer(); // Increased Y fall threshold

            // Camera Update
            let targetCameraX = player.x - gameWidth / 2 + player.width / 2;
            camera.x += (targetCameraX - camera.x) * 0.1; // Smooth follow
            camera.x = Math.max(0, camera.x);
            camera.x = Math.min(levelActualWidth - gameWidth, camera.x);
            if (levelActualWidth <= gameWidth) camera.x = 0; // No scroll if level is not wider
        }

        function draw() {
            ctx.fillStyle = gameBackgroundColor; // Sky
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            ctx.save();
            ctx.translate(-camera.x, -camera.y); // Apply camera offset

            // Draw Ground Segments
            ctx.fillStyle = groundColor;
            groundSegments.forEach(segment => {
                ctx.fillRect(segment.x, segment.y, segment.width, segment.height);
            });

            // Draw Start/Goal
            if (startZone) { ctx.fillStyle = startColor; ctx.fillRect(startZone.x, startZone.y, startZone.width, startZone.height); ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.fillText("START", startZone.x + startZone.width / 2, startZone.y + startZone.height / 2 + 5); }
            if (goalZone) { ctx.fillStyle = goalColor; ctx.fillRect(goalZone.x, goalZone.y, goalZone.width, goalZone.height); ctx.fillStyle = 'black'; ctx.textAlign = 'center'; ctx.fillText("GOAL", goalZone.x + goalZone.width / 2, goalZone.y + goalZone.height / 2 + 5); }

            // Draw Spikes
            if (spikes) {
                ctx.fillStyle = spikeColor;
                spikes.forEach(spike => { /* ... draw spike path ... */
                    ctx.beginPath();
                    ctx.moveTo(spike.x, spike.y + spike.height);
                    ctx.lineTo(spike.x + spike.width / 2, spike.y);
                    ctx.lineTo(spike.x + spike.width, spike.y + spike.height);
                    ctx.closePath(); ctx.fill();
                });
            }

            // Draw Placed Blocks
            ctx.fillStyle = blockColor;
            placedBlocks.forEach(block => ctx.fillRect(block.x, block.y, block.width, block.height));

            // Draw Player
            ctx.fillStyle = player.isDashing ? '#FF69B4' : playerColor;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            ctx.restore(); // Remove camera offset for UI elements if any were drawn after

            // If any UI needs to be drawn fixed on screen, do it after ctx.restore()
        }

        // ... (updateUI, placeBlock, performDash, gameLoop, event listeners, fullscreen logic - copy from previous version)
        function updateUI() { blockCountDisplay.textContent = `Blocks: ${player.blocksAvailable}`; levelDisplay.textContent = `Level: ${currentLevel}`; }
        function placeBlock() {
            if (player.blocksAvailable > 0) {
                placedBlocks.push({
                    x: player.x + (player.width / 2) - (blockWidth / 2), // Place relative to player's world X
                    y: player.y + player.height, width: blockWidth, height: blockHeight
                });
                player.blocksAvailable--; updateUI();
            } else {
                messageDisplay.textContent = "Out of blocks!";
                setTimeout(() => { if(messageDisplay.textContent === "Out of blocks!") messageDisplay.textContent = ""; }, 1500);
            }
        }
        function performDash() { /* ... same as before ... */
             if (!player.isDashing) {
                player.isDashing = true; player.dashTimer = dashDuration;
                if (keys.left) player.dashDirection = -1;
                else if (keys.right) player.dashDirection = 1;
                else player.dashDirection = (player.x < camera.x + gameWidth / 2 ? 1 : -1); // Dash based on screen pos for intuitive feel
                if (player.dashDirection === 0) player.dashDirection = 1;
            }
        }
        function gameLoop() { requestAnimationFrame(gameLoop); update(); draw(); }
        window.addEventListener('keydown', function(e) {
            if (document.activeElement === fullscreenBtn && e.key === 'Enter') { if (!document.fullscreenElement) openFullscreen(gameContainer); else closeFullscreen(); return; }
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === ' ') { e.preventDefault(); keys.up = true; if (player.onGround && !player.isDashing) { player.dy = jumpStrength; player.onGround = false; } }
            if (e.key === 'x' || e.key === 'X') placeBlock();
            if (e.key === 'c' || e.key === 'C') performDash();
        });
        window.addEventListener('keyup', function(e) {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === ' ') keys.up = false;
        });
        function openFullscreen(elem) { if (elem.requestFullscreen) elem.requestFullscreen(); else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen(); else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen(); else if (elem.msRequestFullscreen) elem.msRequestFullscreen(); }
        function closeFullscreen() { if (document.exitFullscreen) document.exitFullscreen(); else if (document.mozCancelFullScreen) document.mozCancelFullScreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); else if (document.msExitFullscreen) document.msExitFullscreen(); }
        fullscreenBtn.addEventListener('click', function() { if (!document.fullscreenElement) openFullscreen(gameContainer); else closeFullscreen(); });
        function updateFullscreenButtonText() { fullscreenBtn.textContent = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ? "Exit Fullscreen" : "Go Fullscreen"; }
        document.addEventListener('fullscreenchange', updateFullscreenButtonText); document.addEventListener('mozfullscreenchange', updateFullscreenButtonText); document.addEventListener('webkitfullscreenchange', updateFullscreenButtonText); document.addEventListener('msfullscreenchange', updateFullscreenButtonText);

        setupLevel(currentLevel);
        updateFullscreenButtonText();
        gameLoop();
    </script>
</body>
</html>
